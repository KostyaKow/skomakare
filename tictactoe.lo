;$ cargo run
;(l "tictactoe.lo")

(define normalize-square (lambda (square) (do
   (resize square 0.29 0.29)
   (move square -0.5 0.3))))

(define get-squares (lambda (color)
   (loop 9 (lambda () (square color)))))

(define square-index-to-xy (lambda (n) (do
   (define x
      (if (> n 6)
         (- n 6)
         (if (> n 3) (- n 3) n)))
   (define y
      (if (> n 6)
         2
         (if (> n 3) 1 0)))
   (cons x y))))

(define set-square-pos (lambda (square x y)
   (move square (* 0.3 x) (- 0 (* 0.3 y)))))

(define draw-board (lambda (init-color) (do
   (define squares (get-squares init-color))
   (map (lambda (x) (normalize-square x)) squares)
   (define fold_f (lambda (square n) (do
      (print (+ "current n:" n " square: " square))
      (define xy (square-index-to-xy n))
      (set-square-pos square (car xy) (cdr xy))
      (+ n 1))))
   (print "calling fold with: ")
   (fold fold_f 1 squares)

   squares)))

(define get-player (lambda (x) (if (null? x) nil (car x))))
(define get-square-model-n (lambda (x) (cdr x)))
(define get-square (lambda (board x) (list-ref board x)))

;pass item = (cons "player-color" squaren) -> return player who won
(define check-3 (lambda (a b c) (do
   (define player-abc (map (lambda (square) (get-player square)) (cons a (cons b (cons c nil)))))
;   (print (+ "checking " (list-ref player-abc 0) " " (list-ref player-abc 1) " " (list-ref player-abc 2)))
   (define first (car player-abc))
   (if (apply = player-abc)
      first
      "e"))))

;TODO: make this work for vertical and horizontal
(define check-winner (lambda (board) (do
;   (define rows
;      (map (lambda (x) (do
;               (define n (* x 3))
;               (cons n (cons (+ n 1) (cons (+ n 2) nil)))))
;           (range 0 2)))
;   (define row-win
;      (map (lambda (row)
;               (apply check-3 (map (lambda (x) (get-square board x)) row)))
;           rows))
   (define row-win-1 (check-3 (get-square board 0) (get-square board 1) (get-square board 2)))
   (define row-win-2 (check-3 (get-square board 3) (get-square board 4) (get-square board 5)))
   (define row-win-3 (check-3 (get-square board 6) (get-square board 7) (get-square board 8)))
   (define row-win (cons row-win-1 (cons row-win-2 (cons row-win-3 nil))))

   (define diag-win-1 (check-3 (get-square board 0) (get-square board 4) (get-square board 8)))
   (define diag-win-2 (check-3 (get-square board 2) (get-square board 4) (get-square board 6)))
   (define diag-win (cons diag-win-1 (cons diag-win-2 nil)))

   (define col-win-1 (check-3 (get-square board 0) (get-square board 3) (get-square board 6)))
   (define col-win-2 (check-3 (get-square board 1) (get-square board 4) (get-square board 7)))
   (define col-win-3 (check-3 (get-square board 2) (get-square board 5) (get-square board 8)))
   (define col-win (cons col-win-1 (cons col-win-2 (cons col-win-3 nil))))

   (define any-win (filter (lambda (x) (not (= x "e")))
                           (append row-win (append col-win diag-win))))
   (if (> (length any-win) 0)
      (car any-win)
      "e"))))

(define get-mouse-clicks (lambda () (do
   (define events (check_events))
   (if (null? events)
;      (do (print "no events") (cons 0 0))
      (cons 0 0)
      (if (= (car events) "mouse")
         (do (define clicks (cdr events))
;             (print (+ "click x: " (car clicks) " y: " (cdr clicks)))
             clicks)
         (do (+ 1 1)
;             (print "non-click event")
             (cons 0 0)))))))

;TODO: test this out
;0-9 or -1 if not on square
(define map-click-to-square (lambda (x y) (do
   (define row-1-y-start 0.278)
   (define row-1-y-end 0.423)
   (define col-1-x-start 0.328)
   (define col-1-x-end 0.43)

   (define row-2-y-start 0.423)
   (define row-2-y-end 0.57)
   (define col-2-x-start 0.47)
   (define col-2-x-end 0.62)

   (define row-3-y-start 0.57)
   (define row-3-y-end 0.72)
   (define col-3-x-start 0.63)
   (define col-3-x-end 0.774)

   (define col-click
      (if (and (> x col-1-x-start) (< x col-1-x-end))
         0
         (if (and (> x col-2-x-start) (< x col-2-x-end))
            1
            (if (and (> x col-3-x-start) (< x col-3-x-end))
               2
               -1))))
   (define row-click
      (if (and (> y row-1-y-start) (< y row-1-y-end))
         0
         (if (and (> y row-2-y-start) (< y row-2-y-end))
            1
            (if (and (> y row-3-y-start) (< y row-3-y-end))
               2
               -1))))
   (print (+ "col-click: " col-click))
   (print (+ "row-click: " row-click))
   (if (or (= row-click -1) (= col-click -1))
      -1
      (+ (* row-click 3) col-click)))))

;TODO: checks if square is free, and if it is, then return ok move
;(define test-ok-move (lambda (board square)
;   (and (not (= square -1)) (= "e" (get-player (get-square board square))))))
(define test-ok-move (lambda (board square)
   (if (= square -1)
      false
      (do
          (define player (get-player (get-square board square)))
          (if (null? player)
               false
               (= "e" player))))))

(define get-next-player (lambda (cur-player) (if (= cur-player "w") "b" "w")))

(define test-loop (lambda () (do (print "got here ok") (sleep 2))))

(define get-square-color (lambda (player)
   (if (= player "w") "resources/x.png" (if (= player "b") "resources/o.png" red))))

(define p-to-name (lambda (p) (if (= p "w") "x" "o")))

;TODO: implement gameplay
(define play (lambda (n board p-turn)
   (if (= n 0) "oops gotta increase n when calling (play n board)"
      (do
         (print-board board)
         (sleep 0.1)
         (define clicks (get-mouse-clicks))
         (define clicked-square (map-click-to-square (car clicks) (cdr clicks)))
         (print (+ "clicked on square " clicked-square))
         (if (test-ok-move board clicked-square)
            (do (define move-square (get-square board clicked-square))
                (define xy (square-index-to-xy (+ 1 clicked-square)))
                (define new-square (square (get-square-color p-turn)))
                (normalize-square new-square)
                (set-square-pos new-square (car xy) (cdr xy))
                (move (get-square-model-n move-square) 10 10)
                (define new-board (modify-lst board clicked-square (cons p-turn new-square)))
                (define winner (check-winner new-board))
                (if (= winner "e")
                  (do (play (- n 1)
                            new-board
                            (get-next-player p-turn)))
                  (print (+ (p-to-name p-turn) " won!!!"))))
            (do (print "not ok move")
                (play (- n 1) board p-turn)))))))

(define print-board (lambda (board) (do
   (define str-brd
      (fold (lambda (square init_str) (+ init_str " " (car square)))
            ""
            board))
   (print (+ "board: " str-brd)))))

(define game (lambda () (do
   (define board-locations (draw-board red))
;(w)hite, (b)lack, (e)mpty
   (define board (map (lambda (s) (cons "e" s)) board-locations))
   (play 1000 board "w"))))

(game)
