;$ cargo run
;(l "tictactoe.lo")

(define normalize-square (lambda (square) (do
   (resize square 0.29 0.29)
   (move square -0.5 0.3))))

(define get-squares (lambda (color)
   (loop 9 (lambda () (s color)))))

(define square-index-to-xy (lambda (n) (do
   (define x
      (if (> n 6)
         (- n 6)
         (if (> n 3) (- n 3) n)))
   (define y
      (if (> n 6)
         2
         (if (> n 3) 1 0)))
   (cons x y))))

(define set-square-pos (lambda (square x y)
   (move square (* 0.3 x) (- 0 (* 0.3 y)))))

(define draw-board (lambda (init_color) (do
   (define squares (get-squares init_color))
   (map (lambda (x) (normalize-square x)) squares)
   (define fold_f (lambda (square n) (do
      (print (+ "current n:" n " square: " square))
      (define xy (square-index-to-xy n))
      (set-square-pos square (car xy) (cdr xy))
      (+ n 1))))
   (print "calling fold with: ")
   (fold fold_f 1 squares)

   squares)))

(define apply (lambda (f lst) (do
   (define len (length lst))
   (if (= len 0)
      (f)
      (if (= len 1)
         (f (car lst))
         (if (= len 2)
            (f (car lst) (cadr lst))
            (if (= len 3)
               (f (car lst) (cadr lst) (list-ref lst 2))
               (print (+ "can't apply function to " (length lst) " arguments")))))))))

;pass item = (cons "player-color" squaren) -> return player who won
(define check-3 (lambda (items) (do
   (define player-abc (map (lambda (x) (car x)) items))
   (define first (car player-abc))
   (if (apply = player-abc)
      first
      "e"))))

(define get-square (lambda (board x) (list-ref board x)))

;TODO: make this work for vertical and horizontal
(define check-winner (lambda (board) (do
   (define rows
      (map (lambda (x) (do
               (define n (* x 3))
               (cons n (cons (+ n 1) (cons (+ n 2) nil)))))
           (range 0 2)))
   (define row-win
      (map (lambda (row)
               (check-3 (map (lambda (x) (get-square board x)) row)))
           rows))
   (define col-win nil)
   (define diag-win nil)
   (define any-win (filter (lambda (x) (not (= x "e")))
                           (append row-win (append col-win diag-win))))
   (if (> (length any-win) 0)
      (car any-win)
      "e"))))

(define get-mouse-clicks (lambda () (do
   (define events (check_events))
   (if (null? events)
;      (do (print "no events") (cons 0 0))
      (cons 0 0)
      (if (= (car events) "mouse")
         (do (define clicks (cdr events))
;             (print (+ "click x: " (car clicks) " y: " (cdr clicks)))
             clicks)
         (do
;             (print "non-click event")
             (cons 0 0)))))))

;TODO: test this out
;0-9 or -1 if not on square
(define map-click-to-square (lambda (x y) (do
   (define row-1-y-start 0.278)
   (define row-1-y-end 0.423)
   (define col-1-x-start 0.328)
   (define col-1-x-end 0.43)

   (define row-2-y-start 0.423)
   (define row-2-y-end 0.57)
   (define col-2-x-start 0.47)
   (define col-2-x-end 0.62)

   (define row-3-y-start 0.57)
   (define row-3-y-end 0.72)
   (define col-3-x-start 0.63)
   (define col-3-x-end 0.774)

   (define col-click
      (if (and (> x col-1-x-start) (< x col-1-x-end))
         0
         (if (and (> x col-2-x-start) (< x col-2-x-end))
            1
            (if (and (> x col-3-x-start) (< x col-3-x-end))
               2
               -1))))
   (define row-click
      (if (and (> y row-1-y-start) (< y row-1-y-end))
         0
         (if (and (> y row-2-y-start) (< y row-2-y-end))
            1
            (if (and (> y row-3-y-start) (< y row-3-y-end))
               2
               -1))))
   (print (+ "col-click: " col-click))
   (print (+ "row-click: " row-click))
   (if (or (= row-click -1) (= col-click -1))
      -1
      (+ (* row-click 3) col-click)))))

;TODO: checks if square is free, and if it is, then return ok move
(define test-ok-move (lambda (board square)
   (and (not (= square -1)) (= "e" (car (get-square board square))))))

(define get-next-player (lambda (cur-player) (if (= cur-player "w") "b" "w")))

;TODO: implement gameplay
(define play (lambda (n b p_turn)
   (if (= n 0) "oops gotta increase n when calling (play n board)"
      (do
         (sleep 0.5)
         (print "got here ok")
         (define clicks (get-mouse-clicks))
         (define square-click (map-click-to-square (car clicks) (cdr clicks)))
         (if (test-ok-move b square-click)
            (do (print (+ p_turn " moves to square: " square-click))
                (define winner (check-winner b))
                (if (= winner "e")
                  (do (define last-move (get-square b square-click))
                      (play (- n 1)
                            (modify-lst b square-click (cons p_turn (cdr last-move)))
                            (get-next-player p_turn)))
                  (print (+ p_turn " won!!!"))))
            (play (- n 1) b p_turn))))))

(define game (lambda () (do
   (define board-locations (draw-board red))
;(w)hite, (b)lack, (e)mpty
   (define board (map (lambda (s) (cons "e" s))))
   (play 100 board "w"))))

(game)
